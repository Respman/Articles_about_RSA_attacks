\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{tikz}

\begin{document}
	
\section{Дискретное логарифмирование}

Задача дискретного логарифмирования заключается в том, чтобы по данным целым $a$, $b$, $m$ решить уравнение:

$$a^x = b \pmod m,$$

где $a$ и $m$ — взаимно просты (если они не взаимно просты, то описанный ниже алгоритм является некорректным; хотя, предположительно, его можно модифицировать, чтобы он по-прежнему работал).

Опишем алгоритм, известный как 'baby-step-giant-step algorithm', предложенный Шэнксом (Shanks) в 1971 г. Часто этот алгоритм просто называют алгоритмом 'meet-in-the-middle', потому что это одно из классических применений техники 'meet-in-the-middle': 'разделение задачи пополам'.\\

\textbf{Алгоритм}

Итак, мы имеем сравнение:

$$a^x = b \pmod m,$$

где $a$ и $m$ взаимно просты.

Преобразуем сравнение. Положим

$$x = np - q,$$

где $n$ — это заранее выбранная константа,  $n \approx \sqrt{m}$. Иногда $p$ называют 'giant step' (поскольку увеличение его на единицу увеличивает $x$ сразу на $n$), а в противоположность ему $q$ — 'baby step'.

Очевидно, что любое $x$ из промежутка $[0;m)$ (понятно, что такого диапазона значений будет достаточно) можно представить в такой форме, причём для этого будет достаточно значений:

$$p \in \left[ 1; \left\lceil \frac{m}{n} \right\rceil \right],\qquad q \in [0;n].$$

Тогда уравнение принимает вид:

$$a^{np-q} = b \pmod m,$$

откуда, пользуясь тем, что $a$ и $m$ взаимно просты, получаем:

$$a^{np} = b a^q \pmod m.$$

Чтобы решить исходное уравнение, нужно найти соответствующие значения $p$ и $q$, чтобы значения левой и правой частей совпали. Иначе говоря, надо решить уравнение:

$$f_1(p) = f_2(q).$$

Эта задача решается с помощью метода 'meet-in-the-middle' следующим образом:\\

\underline{Первая фаза алгоритма:} посчитаем значения функции $f_1$ для всех значений аргумента $p$, и отсортируем эти значения.

\underline{Вторая фаза алгоритма:} будем перебирать значение второй переменной $q$, вычислять вторую функцию $f_2$, и искать это значение среди предвычисленных значений первой функции с помощью бинарного поиска.

Данны алгоритм работает за время $O(\sqrt{m}\log{m})$.\\

\textbf{Источник:}

\href{https://e-maxx.ru/algo/discrete_log}{https://e-maxx.ru/algo/discrete\_log}
	
\end{document}
