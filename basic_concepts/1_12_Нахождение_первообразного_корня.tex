\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{tikz}

\begin{document}
	
\section{Алгоритм нахождения первообразного корня}

Наивный алгоритм потребует для каждого тестируемого значения $g\ O(n)$ времени, чтобы вычислить все его степени и проверить, что они все различны. Это слишком медленный алгоритм, поэтому ниже мы с помощью нескольких известных теорем из теории чисел получим более быстрый алгоритм.

Малая теорема Ферма говорит нам о том, что если наименьшее число $k$, для которого $g^k \equiv 1 \pmod{n}$ (т.е. $k$ — показатель $g$), равно $\phi(n)$, то $g$ — первообразный корень. Так как для любого числа $a$, взаимно простого с $n$, выполняется теорема Эйлера $(a^{\phi(n)} \equiv 1 \pmod{n})$, то чтобы проверить, что $g$ первообразный корень, достаточно проверить, что для всех чисел $d$, меньших $\phi(n)$, выполнялось $g^d \not\equiv 1 \pmod{n}$. Однако пока это слишком медленный алгоритм.

Из теоремы Лагранжа следует, что показатель любого числа по модулю $n$ является делителем $\phi(n)$. Таким образом, достаточно проверить, что для всех собственных делителей $d\ |\ \phi(n)$ выполняется $g^d \not\equiv 1 \pmod{n}$. Это уже значительно более быстрый алгоритм, однако можно пойти ещё дальше.

Факторизуем число $\phi(n) = p_1^{a_1} \ldots p_s^{a_s}$. Докажем, что в предыдущем алгоритме достаточно рассматривать в качестве $d$ лишь числа вида $\frac{ \phi(n) }{ p_i }$. Действительно, пусть $d$ — произвольный собственный делитель $\phi(n)$. Тогда, очевидно, найдётся такое $j$, что $d\ |\ \frac{ \phi(n) }{ p_j }$, т.е. $d \cdot k = \frac{ \phi(n) }{ p_j }$. Однако, если бы $g^d \equiv 1 \pmod{n}$, то мы получили бы:

$$g^{\frac{ \phi(n) }{ p_j }} \equiv g^{d \cdot k} \equiv (g^d)^k \equiv 1^k \equiv 1\ (mod\ n),$$

то есть всё равно среди чисел вида $\frac{ \phi(n) }{ p_i }$ нашлось бы то, для которого условие не выполнилось, что и требовалось доказать.

Таким образом, алгоритм нахождения первообразного корня такой:\\

Находим $\phi(n)$, факторизуем его. Теперь перебираем все числа $g = 1 \ldots n$, и для каждого считаем все величины $g^{ \frac{ \phi(n) }{ p_i } } \pmod{n}$. Если для текущего $g$ все эти числа оказались отличными от $1$, то это $g$ и является искомым первообразным корнем.\\

Время работы алгоритма (считая, что у числа $\phi(n)$ имеется $O \left( \log \phi(n) \right)$ делителей, а возведение в степень выполняется алгоритмом Бинарного возведения в степень, т.е. за $O(\log n))$ равно $O \left( Ans \cdot \log \phi(n) \cdot \log n \right)$ плюс время факторизации числа $\phi(n)$, где $Ans$ — результат, то есть значение искомого первообразного корня.

Про скорость роста первообразных корней с ростом $n$ известны лишь приблизительные оценки. Известно, что первообразные корни — сравнительно небольшие величины. Одна из известных оценок — оценка Шупа (Shoup): в предположении истинности гипотезы Римана (одной из семи 'задач тысячелетия', которая пока не решена), первообразный корень имеет порядок $O (\log^6 n)$.\\

\textbf{Источник:}

\href{https://e-maxx.ru/algo/primitive_root}{https://e-maxx.ru/algo/primitive\_root}
	
\end{document}
