\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{minted} %для вставки кода в документ

\begin{document}

\section{Плохая проверка сгенерированных чисел на простоту}

Здесь речь идёт о генераторах простых чисел, в которых простота случайно сгенерированного числа проверяется вероятностными алгоритмами. То есть существует ненулевой шанс (который зависит от используемого алгоритма проверки на простоту), что число, выданное таким генератором и прошедшее проверку, будет непростым - в таком случае факторизация числа упростится и стойкость шифра понизится.

Но на данный момент уже существуют детерминированные алгоритмы проверки числа на простоту (например, \href{https://yatb.kksctf.ru/}{алгоритм Агравала-Каяла-Саксены}), которые со 100\% - ной вероятностью выяснят, является ли число простым или составным.\\

\textbf{Пример слабой проверки на простоту}

Примером может быть тест, который проверяет делимость числа на первые 20 простых чисел: если ни одно из этих простых чисел не будет делить проверяемое число, то его будут считать простым. Но такой тест будет достаточно часто ошибаться, одобряя составные числа, что приведёт к упрощению факторизации полученного модуля противником.\\

\textbf{Sage-реализация:}\\

\inputminted[tabsize=4,obeytabs,fontsize=\footnotesize]{python3}{./RSA_scripts/prime.sage}

Также к уязвимостям рандома можно добавить все уязвимости ГПСЧ: например, можно подобрать начальное состояние генератора (seed) и таким образом узнать сгенерированные им $p$ и $q$.\\

\end{document}
